// parser

let tap = require("tap")
let fs = require("fs").promises
let {resolve: resolvePath} = require("path")
let execa = require("execa")
let {getProblemsAndOpinions} = require("../cjs")

// We have a =ProblemInfo= type that is parsed from the github action annotation
// output generated by the cli.

// It contains the severity, the error code and the file name. if available, it
// also includes the line and column.

/**
 * @typedef ProblemInfo
 * @property {string} code
 * @property {string} file
 * @property {number=} line
 * @property {number=} column
 * @property {string} severity
 */

// Here we parse the =key=value= pairs into the ProblemInfo object, coercing
// lines and columns to numbers

/**
 * @param {string} info
 * @returns {ProblemInfo}
 */
function parseInfo(info) {
	let fields = info.split(",")
	let result = {}
	for (let keyvalue of fields) {
		let [key, value] = keyvalue.split("=")
		switch (key) {
			case "code":
			case "file":
			case "severity":
				result[key] = value
				break
			case "line":
				result[key] = Number(value)
				break

			// The column number is called ~col~ in the github
			// action, but we use ~column~ in our fixtures.

			case "col":
				result.column = Number(value)
		}
	}
	return result
}

// We parse =stdout= as a series of errors/warnings

/** @param {import("execa").ExecaReturnValue} result */
function parse(result) {
	let errors = {}
	let warnings = {}

	let matches = result.stdout.matchAll(/::(?<severity>[^ ]+) (?<info>[^:]+)::/g)

	for (let match of matches) {
		let {code, severity, ...info} = parseInfo(match.groups.info)

		// the github log level should match the severity in the info fields

		if (severity != match.groups.severity) {
			tap.fail(
				`severity should match problem level. got ${severity} and ${match.groups.severity}`
			)
		}

		if (severity == "error") {
			errors[code] = info
		} else if (severity == "warning") {
			warnings[code] = info
		} else {
			tap.fail(`severity should be "error" or "warning", got ${severity}`)
		}
	}

	return {
		errors,
		warnings,
	}
}

// test runner
// The components are stored in a structure like this:
// ├── names-arent-the-same
// │   ├── component
// │   │   ├── bower.json
// │   │   ├── origami.json
// │   │   └── package.json
// │   └── expected.json

// The =expected.json= file contains a structure the same as what is created by
// the parse functions above:
// {
//         "errors": {
//                 "bower-npm-names-no-match" : {
//                         "file": "package.json",
//                         "line": 2,
//                         "column": 10
//                 }
//         },
//         "warnings": {}
// }

// In the test runner, we execute the cli on each of the ~test-name/component~
// directories, and create a [[https://node-tap.org/][tap]] test for each one,
// checking that the parsed output matches the ~expected.json~ file.

/** @param {string} testName */
async function test(testName) {
	let testDirectory = resolvePath(__dirname, testName)
	let expectedFile = resolvePath(testDirectory, "expected.json")
	let expected = JSON.parse(await fs.readFile(expectedFile))

	let componentDirectory = resolvePath(testDirectory, "component")

	let actual = parse(
		await execa(
			"node",
			[resolvePath(__dirname, ".."), componentDirectory, "github"],
			{
				cwd: componentDirectory,
				env: {
					FORCE_COLOR: 0,
					NODE_ENV: "inner-test",
				},
			}
		)
	)

	tap.test(testName, t => {
		t.strictDeepEqual(expected, actual)
		t.done()
	})
}

let all = (list, fn) => Promise.all(list.map(fn))

fs.readdir(__dirname).then(async filenames => {
	await all(filenames, filename => {
		if (filename == "test.js") {
			return
		}

		return test(filename)
	})
})
