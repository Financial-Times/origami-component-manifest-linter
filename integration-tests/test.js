// parser

let tap = require("tap")
let fs = require("fs").promises
let {resolve: resolvePath} = require("path")
let execa = require("execa")
const {Dirent} = require("fs")

// We have a =ProblemInfo= type that is parsed from the github action annotation
// output generated by the cli.

// It contains the severity, the error code and the file name. if available, it
// also includes the line and column.

/**
 * @typedef ProblemInfo
 * @property {string} code
 * @property {string} file
 * @property {number=} line
 * @property {number=} col
 * @property {string} severity
 */

/**
 * @param {string} info
 * @returns {ProblemInfo}
 */
function parseInfo(info) {
	let fields = info.split(",")
	let result = {}
	for (let keyvalue of fields) {
		let [key, value] = keyvalue.split("=")
		switch (key) {
			case "code":
			case "file":
			case "severity":
				result[key] = value
				break
			case "line":
			case "col":
				result[key] = Number(value)
		}
	}
	return result
}

// We parse =stdout= as a series of errors/warnings

/** @param {import("execa").ExecaReturnValue} execaReturnValue */
function parseGithubOutput(execaReturnValue) {
	let lines = []

	let matches = execaReturnValue.stdout.matchAll(
		/::(?<severity>[^ ]+) (?<info>[^:]+)::/g
	)

	for (let match of matches) {
		let info = parseInfo(match.groups.info)

		// the github log level should match the severity in the info fields
		if (info.severity != match.groups.severity) {
			tap.fail(
				`severity should match problem level. got ${severity} and ${match.groups.severity}`
			)
		}

		lines.push(
			`${info.severity} ${info.file} ${info.line || 0} ${info.col || 0} ${
				info.code
			}`
		)
	}

	return lines.sort()
}

// test runner
// The components are stored in a structure like this:
// ├── names-arent-the-same
// │   ├── component
// │   │   ├── bower.json
// │   │   ├── origami.json
// │   │   └── package.json
// │   │── github
// │   └── model.json

// The =github= file contains a structure the same as what is created by
// the parse functions above:
// severity file-name line col code
// severity file-name line col code
// ...

// The =model.json= file is the entire parsed model.

// In the test runner, we execute the cli on each of the ~test-name/component~
// directories, and create a [[https://node-tap.org/][tap]] test for each one,
// checking that the parsed github output matches the ~github.json~ file,
// and that the model output matches the model.json file.
/** @param {string} testName */
async function test(testName) {
	let testDirectory = resolvePath(__dirname, testName)
	let githubExpectedFile = resolvePath(testDirectory, "github")
	let githubExpected = (await fs.readFile(githubExpectedFile, "utf-8"))
		.trim()
		.split("\n")
		.filter(n => n.length && !n.startsWith("#"))
		.sort()

	let modelExpectedFile = resolvePath(testDirectory, "model.json")
	let modelExpected = JSON.parse(await fs.readFile(modelExpectedFile, "utf-8"))

	let componentDirectory = resolvePath(testDirectory, "component")
	let execOptions = {
		cwd: componentDirectory,
		env: {
			FORCE_COLOR: 0,
			NODE_ENV: "inner-test",
		},
	}
	let execArguments = [resolvePath(__dirname, ".."), componentDirectory]
	let githubActual = parseGithubOutput(
		await execa("node", execArguments.concat("github"), execOptions)
	)
	let modelActual
	try {
		let {stdout} = await execa(
			"node",
			execArguments.concat("model"),
			execOptions
		)
		modelActual = JSON.parse(stdout)
	} catch (error) {
		modelActual = error
	}

	tap.test(testName, t => {
		tap.test(`${testName} github output`, t => {
			t.same(githubActual, githubExpected)
			t.done()
		})
		tap.test(`${testName} model output`, t => {
			t.same(modelActual, modelExpected)
			t.done()
		})
		t.done()
	})
}

/** @param {Dirent} entry */
function maybeRunTest(entry) {
	if (entry.isDirectory()) {
		return test(entry.name)
	}
}

fs.readdir(__dirname, {withFileTypes: true}).then(files =>
	files.forEach(maybeRunTest)
)
