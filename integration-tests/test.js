// parser

let tap = require("tap")
let fs = require("fs").promises
let {resolve: resolvePath} = require("path")
let execa = require("execa")
const {Dirent} = require("fs")

// We have a =ProblemInfo= type that is parsed from the github action annotation
// output generated by the cli.

// It contains the severity, the error code and the file name. if available, it
// also includes the line and column.

/**
 * @typedef ProblemInfo
 * @property {string} code
 * @property {string} file
 * @property {number=} line
 * @property {number=} col
 * @property {string} severity
 */

// Here we parse the =key=value= pairs into the ProblemInfo object, coercing
// lines and columns to numbers

/**
 * @param {string} info
 * @returns {ProblemInfo}
 */
function parseInfo(info) {
	let fields = info.split(",")
	let result = {}
	for (let keyvalue of fields) {
		let [key, value] = keyvalue.split("=")
		switch (key) {
			case "code":
			case "file":
			case "severity":
				result[key] = value
				break
			case "line":
			case "col":
				result[key] = Number(value)
		}
	}
	return result
}

// We parse =stdout= as a series of errors/warnings

/** @param {import("execa").ExecaReturnValue} result */
function parseGithubOutput(result) {
	let errors = {}
	let warnings = {}

	let matches = result.stdout.matchAll(/::(?<severity>[^ ]+) (?<info>[^:]+)::/g)

	for (let match of matches) {
		let {code, severity, ...info} = parseInfo(match.groups.info)

		// the github log level should match the severity in the info fields
		if (severity != match.groups.severity) {
			tap.fail(
				`severity should match problem level. got ${severity} and ${match.groups.severity}`
			)
		}

		if (severity == "error") {
			errors[code] = info
		} else if (severity == "warning") {
			warnings[code] = info
		} else {
			tap.fail(`severity should be "error" or "warning", got ${severity}`)
		}
	}

	return {
		errors,
		warnings,
	}
}

// test runner
// The components are stored in a structure like this:
// ├── names-arent-the-same
// │   ├── component
// │   │   ├── bower.json
// │   │   ├── origami.json
// │   │   └── package.json
// │   │── github.json
// │   └── model.json

// The =github.json= file contains a structure the same as what is created by
// the parse functions above:
// {
//         "errors": {
//                 "bower-npm-names-no-match" : {
//                         "file": "package.json",
//                         "line": 2,
//                         "col": 10
//                 }
//         },
//         "warnings": {}
// }

// The =model.json= file is the entire parsed model.

// In the test runner, we execute the cli on each of the ~test-name/component~
// directories, and create a [[https://node-tap.org/][tap]] test for each one,
// checking that the parsed github output matches the ~github.json~ file,
// and that the model output matches the model.json file.
/** @param {string} testName */
async function test(testName) {
	let testDirectory = resolvePath(__dirname, testName)
	let githubExpectedFile = resolvePath(testDirectory, "github.json")
	let githubExpected = JSON.parse(await fs.readFile(githubExpectedFile))

	let modelExpectedFile = resolvePath(testDirectory, "model.json")
	let modelExpected = JSON.parse(await fs.readFile(modelExpectedFile))

	let componentDirectory = resolvePath(testDirectory, "component")
	let execOptions = {
				cwd: componentDirectory,
				env: {
					FORCE_COLOR: 0,
					NODE_ENV: "inner-test",
				},
	}
	let execArguments = [resolvePath(__dirname, ".."), componentDirectory]
	let githubActual = parseGithubOutput(
		await execa(
			"node",
			execArguments.concat("github"),
			execOptions
		)
	)
	let modelActual
	try {
		let {stdout} = await execa(
			"node",
			execArguments.concat("model"),
			execOptions
		)
		modelActual = JSON.parse(stdout)
	} catch (error) {
		modelActual = error
	}

	tap.test(testName, t => {
		tap.test("github output", t => {
			t.strictDeepEqual(githubExpected, githubActual)
			t.done()
		})
		tap.test("model output", t => {
			t.strictDeepEqual(modelExpected, modelActual)
			t.done()
		})
		t.done()
	})
}

/** @param {Dirent} entry */
function maybeRunTest(entry) {
	if (entry.isDirectory()) {
		return test(entry.name)
	}
}

fs.readdir(__dirname, {withFileTypes: true}).then(files => files.forEach(maybeRunTest))
