* integration tests

This folder contains a ~test.js~ file that provides a test runner, and a series of directories that provide fixtures.


** parser

#+begin_src javascript :tangle ./test.js :comments org
let tap = require("tap")
let fs = require("fs").promises
let {resolve: resolvePath} = require("path")
let execa = require("execa")
let {getProblemsAndOpinions} = require("../cjs")
#+end_src

We have a =ProblemInfo= type that is parsed from the github action annotation output generated by the cli.

It contains the severity, the error code and the file name. if available, it also includes the line and column.

#+begin_src javascript :tangle ./test.js :comments org
/**
 * @typedef ProblemInfo
 * @property {string} code
 * @property {string} file
 * @property {number=} line
 * @property {number=} column
 * @property {string} severity
 */
#+end_src

Here we parse the =key=value= pairs into the ProblemInfo object, coercing lines and columns to numbers

#+begin_src javascript :tangle ./test.js :comments org
/**
 * @param {string} info
 * @returns {ProblemInfo}
 */
function parseInfo(info) {
        let fields = info.split(",")
        let result = {}
        for (let keyvalue of fields) {
                let [key, value] = keyvalue.split("=")
                switch (key) {
                        case "code":
                        case "file":
                        case "severity":
                                result[key] = value
                                break
                        case "line":
                                result[key] = Number(value)
                                break
#+end_src
The column number is called ~col~ in the github action, but we use ~column~ in our fixtures.
#+begin_src javascript :tangle ./test.js :comments org
                        case "col":
                                result.column = Number(value)
                }
        }
        return result
}
#+end_src

We parse =stdout= as a series of errors/warnings

#+begin_src javascript :tangle ./test.js :comments org
/** @param {import("execa").ExecaReturnValue} result */
function parse(result) {
        let errors = {}
        let warnings = {}

        let matches = result.stdout.matchAll(/::(?<severity>[^ ]+) (?<info>[^:]+)::/g)

        for (let match of matches) {
                let {code, severity, ...info} = parseInfo(match.groups.info)

#+end_src

the github log level should match the severity in the info fields
#+begin_src javascript :tangle ./test.js :comments org

                if (severity != match.groups.severity) {
                        tap.fail(
                                `severity should match problem level. got ${severity} and ${match.groups.severity}`
                        )
                }

                if (severity == "error") {
                        errors[code] = info
                } else if (severity == "warning") {
                        warnings[code] = info
                } else {
                        tap.fail(`severity should be "error" or "warning", got ${severity}`)
                }
        }

        return {
                errors,
                warnings,
        }
}
#+end_src

** test runner
The components are stored in a structure like this:

#+begin_example text
├── names-arent-the-same
│   ├── component
│   │   ├── bower.json
│   │   ├── origami.json
│   │   └── package.json
│   └── expected.json
#+end_example

The =expected.json= file contains a structure the same as what is created by the parse functions above:

#+begin_example json
{
        "errors": {
                "bower-npm-names-no-match" : {
                        "file": "package.json",
                        "line": 2,
                        "column": 10
                }
        },
        "warnings": {}
}
#+end_example

In the test runner, we execute the cli on each of the ~test-name/component~ directories, and create a [[https://node-tap.org/][tap]] test for each one, checking that the parsed output matches the ~expected.json~ file.

#+begin_src javascript :tangle ./test.js :comments org
/** @param {string} testName */
async function test(testName) {
        let testDirectory = resolvePath(__dirname, testName)
        let expectedFile = resolvePath(testDirectory, "expected.json")
        let expected = JSON.parse(await fs.readFile(expectedFile))

        let componentDirectory = resolvePath(testDirectory, "component")

        let actual = parse(
                await execa(
                        "node",
                        [resolvePath(__dirname, ".."), componentDirectory, "github"],
                        {
                                cwd: componentDirectory,
                                env: {
                                        FORCE_COLOR: 0,
                                        NODE_ENV: "inner-test",
                                },
                        }
                )
        )

        tap.test(testName, t => {
                t.strictDeepEqual(expected, actual)
                t.done()
        })
}

let all = (list, fn) => Promise.all(list.map(fn))

fs.readdir(__dirname).then(async filenames => {
        await all(filenames, filename => {
                if (filename == "test.js") {
                        return
                }

                return test(filename)
        })
})
#+end_src
